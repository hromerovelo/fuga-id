"""
BSD 2-Clause License

Copyright (c) 2024, Hilda Romero-Velo
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this
  list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
"""

"""
  Created by Hilda Romero-Velo on November 2024.
"""

"""
Script: launch_query.py
Purpose:
    Executes search commands (Approximate Alignment and BLAST), processes their JSON results,
    and stores the results along with retrieved scores in a database.

Usage:
    python3 launch_query.py <audio> -qid <query_id> -db <path_to_database>

Features:
1. Supports Two Search Types:
    - Approximate Alignment: Includes `-c` (chromatic) and `-d` (diatonic) search types.
    - BLAST: Includes `-c` (chromatic) and `-d` (diatonic) search types.

2. Result Processing:
    - Parses JSON files generated by the search commands to extract:
        - Timing Data: Includes feature extraction, alignment, and location times.
        - Retrieved Scores: Includes `melodic_line_id` and ranking positions.

3. Validation:
    - Ensures that the `query_id` exists in the database before execution.
    - Validates that all `melodic_line_id` values from the JSON files exist in the `Score` table.

4. Database Storage:
    - Saves the averaged timing results in `BLAST_Search` or `Approximate_Alignment_Search` tables.
    - Saves retrieved scores and their rankings in `BLAST_Search_Melodic_Line` or 
      `Approximate_Alignment_Search_Melodic_Line` tables.

5. File Management:
    - Automatically deletes the JSON result file after processing it.

Required Arguments:
    <audio>: Path to the audio file for the query.
    -qid, --query_id: The Query ID associated with the search operation.
    -db, --db_path: Path to the SQLite database.
"""

import argparse
import datetime
import json
import os
import shutil
import sqlite3
import subprocess
import sys


def validate_query_id(query_id, db_path):
    """
    Check if a given query_id exists in the Query table.

    Args:
        query_id (int): The query ID to validate.
        db_path (str): Path to the SQLite database.

    Returns:
        bool: True if the query_id exists, False otherwise.
    """
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT query_id FROM Query WHERE query_id = ?", (query_id,))
        return cursor.fetchone() is not None
    except sqlite3.Error as e:
        print(f"Database error: {e}")
        return False
    finally:
        conn.close()


def validate_melodic_line_id(melodic_line_id, db_path):
    """
    Validate if a given melodic_line_id exists in the Score table.

    Args:
        melodic_line_id (str): The melodic line ID to validate.
        db_path (str): Path to the SQLite database.

    Returns:
        bool: True if the melodic_line_id exists, False otherwise.
    """
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        cursor.execute(
            "SELECT melodic_line_id FROM Melodic_Line WHERE melodic_line_id = ?",
            (melodic_line_id,),
        )
        return cursor.fetchone() is not None
    except sqlite3.Error as e:
        print(f"Database error: {e}")
        return False
    finally:
        conn.close()


def extract_timing_data(data):
    """
    Extract timing information from JSON data.

    Args:
        data (dict): Parsed JSON data containing timing information.

    Returns:
        dict: Timing information.
    """
    return {
        "fe_user_ms": data["timing"]["feature_extraction"]["user_time_ms"],
        "fe_system_ms": data["timing"]["feature_extraction"]["system_time_ms"],
        "fe_clock_ms": data["timing"]["feature_extraction"]["clock_time_ms"],
        "alignment_user_ms": data["timing"]["alignment"]["user_time_ms"],
        "alignment_system_ms": data["timing"]["alignment"]["system_time_ms"],
        "alignment_clock_ms": data["timing"]["alignment"]["clock_time_ms"],
    }


def extract_alignment_results(data, db_path, json_file):
    """
    Extract alignment results from JSON data.

    Args:
        data (dict): Parsed JSON data containing results.
        db_path (str): Path to SQLite database.
        json_file (str): Original JSON file path for error handling.

    Returns:
        tuple: (query_sequence, list of result tuples)
    """
    scores = []

    for idx, (melodic_line_id, score) in enumerate(
        zip(data["alignment"]["score_ids"], data["alignment"]["scores"]), start=1
    ):
        if not validate_melodic_line_id(melodic_line_id, db_path):
            handle_invalid_melodic_line(melodic_line_id, json_file)

        scores.append(
            (
                melodic_line_id,
                float(score),  # alignment score
                idx,  # ranking position
                int(data["alignment"]["score_origin_pos"][idx - 1]),
                int(data["alignment"]["score_end_pos"][idx - 1]),
                int(data["alignment"]["query_origin_pos"][idx - 1]),
                int(data["alignment"]["query_end_pos"][idx - 1]),
            )
        )

    return data["query"], scores


def handle_invalid_melodic_line(melodic_line_id, json_file):
    """Handle invalid melodic line ID by copying JSON and raising error."""
    failed_json_dir = os.path.join(
        os.path.dirname(json_file), "failed_json_melodic_lines"
    )
    os.makedirs(failed_json_dir, exist_ok=True)
    timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S%f")
    failed_json_path = os.path.join(failed_json_dir, f"failed_{timestamp}.json")
    shutil.copy(json_file, failed_json_path)
    raise ValueError(
        "Invalid melodic_line_id {} in JSON results.".format(melodic_line_id)
    )


def process_json_results(json_file, db_path):
    """
    Process JSON results file.

    Args:
        json_file (str): Path to JSON file.
        db_path (str): Path to SQLite database.

    Returns:
        tuple: (timing_data, query_sequence, processed_scores)
    """
    if not os.path.exists(json_file):
        return {}, "", []

    with open(json_file, "r") as file:
        data = json.load(file)

    times = extract_timing_data(data)
    query_sequence, scores = extract_alignment_results(data, db_path, json_file)

    # Check if query_sequence is empty
    if not query_sequence:
        return times, "", scores

    return times, query_sequence, scores


def store_results(
    query_id, algorithm, search_type, query_sequence, times, scores, db_path
):
    """
    Store search results and scores in the database.

    Args:
        query_id (int): Query ID
        algorithm (str): Algorithm type ('BLAST' or 'Approximate_Alignment')
        search_type (str): Type of search ('chromatic', 'diatonic')
        query_sequence (str): Query sequence used in search
        times (dict): Timing data
        scores (list): List of score tuples
        db_path (str): Path to database
    """
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        # Insert search record
        cursor.execute(
            """
            INSERT INTO Search (
                algorithm, search_type, sequence, fe_user_ms, fe_system_ms, 
                fe_clock_ms, alignment_user_ms, alignment_system_ms, 
                alignment_clock_ms, query_id
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """,
            [
                algorithm,
                search_type,
                query_sequence,
                times["fe_user_ms"],
                times["fe_system_ms"],
                times["fe_clock_ms"],
                times["alignment_user_ms"],
                times["alignment_system_ms"],
                times["alignment_clock_ms"],
                query_id,
            ],
        )
        search_id = cursor.lastrowid

        # Insert search results
        for (
            melodic_line_id,
            alignment_score,
            rank,
            score_origin,
            score_end,
            query_origin,
            query_end,
        ) in scores:
            cursor.execute(
                """
                INSERT INTO Search_Results (
                    search_id, melodic_line_id, alignment_score, ranking_position,
                    melodic_line_origin_pos, melodic_line_end_pos,
                    query_origin_pos, query_end_pos
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """,
                (
                    search_id,
                    melodic_line_id,
                    alignment_score,
                    rank,
                    score_origin,
                    score_end,
                    query_origin,
                    query_end,
                ),
            )

        conn.commit()
    except sqlite3.Error as e:
        print(f"Database error: {e}")
    finally:
        conn.close()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Launch query and store results in database."
    )
    parser.add_argument("audio", help="Path to the audio file.")
    parser.add_argument("-qid", "--query_id", type=int, required=True, help="Query ID.")
    parser.add_argument(
        "-db", "--db_path", required=True, help="Path to the SQLite database."
    )
    args = parser.parse_args()

    # Validate inputs
    if not os.path.isfile(args.audio):
        print(f"Error: File {args.audio} does not exist.")
        sys.exit(1)
    if not validate_query_id(args.query_id, args.db_path):
        print(f"Error: Query ID {args.query_id} is invalid.")
        sys.exit(1)

    # Define paths from script directory
    script_dir = os.path.dirname(os.path.abspath(__file__))
    results_dir = os.path.join(script_dir, "../data/results")
    os.makedirs(results_dir, exist_ok=True)
    json_path = os.path.join(results_dir, "score_and_timing_results.json")
    approximate_alignment_executable = os.path.join(
        script_dir, "../bin/approximate_alignment"
    )
    blast_executable = os.path.join(script_dir, "../bin/blast_alignment")

    # Define commands and database table mappings
    commands = [
        (
            approximate_alignment_executable + " -c",
            "Approximate_Alignment",
            "chromatic",
        ),
        (approximate_alignment_executable + " -d", "Approximate_Alignment", "diatonic"),
        (approximate_alignment_executable + " -r", "Approximate_Alignment", "rhythmic"),
        (blast_executable + " -c", "BLAST", "chromatic"),
        (blast_executable + " -d", "BLAST", "diatonic"),
        (blast_executable + " -r", "BLAST", "rhythmic"),
    ]

    # Process commands
    for command_str, algorithm, search_type in commands:
        command = command_str.split() + [args.audio]
        subprocess.run(command, check=True)

        times, query_sequence, processed_scores = process_json_results(
            json_path, args.db_path
        )

        # Skip storing results if query_sequence is empty
        if not query_sequence:
            print(f"Skipping {algorithm} {search_type} due to empty query sequence.")
            continue

        store_results(
            args.query_id,
            algorithm,
            search_type,
            query_sequence,
            times,
            processed_scores,
            args.db_path,
        )

        if os.path.exists(json_path):
            os.remove(json_path)

    # Remove results directory and its contents if it does not contain other directories
    if not any(
        os.path.isdir(os.path.join(results_dir, entry))
        for entry in os.listdir(results_dir)
    ):
        shutil.rmtree(results_dir)
